---
title: "Deconvolution with `SPOTlight`"
date: "`r BiocStyle::doc_date()`"
author:
- name: Marc Elosua-Bayes
  affilitation:
  - &CNAG-CRG National Center for Genomic Analysis - Center for Genomic Regulation
  - &UPF University Pompeu Fabra
  email: marc.elosua@cnag.crg.eu
- name: Helena L. Crowell
  affiliation:
  - &IMLS Institute for Molecular Life Sciences, University of Zurich, Switzerland
  - &SIB SIB Swiss Institute of Bioinformatics, University of Zurich, Switzerland
  email: helena.crowell@uzh.ch
abstract: > 
  <p> Single-cell RNA sequencing (scRNA-seq) has quickly become an empowering technology to profile the transcriptomes of individual cells on a large scale. Many early analyses of differential expression have aimed at identifying differences between subpopulations, and thus are focused on finding subpopulation markers either in a single sample or across multiple samples. More generally, such methods can compare expression levels in multiple sets of cells, thus leading to cross-condition analyses.
  <p> However, given the emergence of replicated multi-condition scRNA-seq  datasets,  an  area  of  increasing  focus  is making  sample-level inferences, termed here as *differential state* (DS) analysis. For example, one could investigate the condition-specific responses of cell subpopulations measured from patients in each condition.
  <p> `muscat`: **mu**lti-sample **mu**lti-group **sc**RNA-seq **a**nalysis **t**ools [@Crowell2019-muscat] provides various methods and visualization tools for DS analysis in multi-sample, multi-group, multi-(cell-)subpopulation scRNA-seq data, including cell-level mixed models and methods based on aggregated “pseudobulk” data, as well as a flexible simulation platform that mimics both single and multi-sample scRNA-seq data.package: "`r BiocStyle::pkg_ver('SPOTlight')`"
bibliography: "`r file.path(system.file('extdata', package = 'SPOTlight'), 'refs.bib')`"
vignette: >
  %\VignetteIndexEntry{"SPOTlight"}
  %\VignettePackage{SPOTlight}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

<style type="text/css">
.smaller {
  font-size: 10px
}
</style>

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(BiocStyle)
```


For a more detailed explanation of `SPOTlight` consider looking at our manuscript:    
> Elosua-Bayes M, Nieto P, Mereu E, Gut I, Heyn H.  
SPOTlight: seeded NMF regression to deconvolute spatial transcriptomics spots   
with single-cell transcriptomes.  
*Nucleic Acids Res.* **2021;49(9):e50**. doi: [10.1093](10.1093/nar/gkab043)

# Load packages {-}

```{r load-libs, message = FALSE,  warning = FALSE}
library(ggplot2)
library(SPOTlight)
library(SingleCellExperiment)
library(SpatialExperiment)
library(scater)
library(scran)
```

# Introduction

## What is SPOTlight?

`SPOTlight`is a tool that enables the deconvolution of cell types and cell type
proportions present within each capture location comprising mixtures of cells.
Originally developed for 10X's Visium - spatial transcriptomics - technology, it
can be used for all technologies returning mixtures of cells.

`SPOTlight` is based on learning topic profile signatures, by means of an NMFreg
model, for each cell type and finding which combination of cell types fits best
the spot we want to deconvolute. Find below a graphical abstract visually 
summarizing the key steps.

![](../inst/extdata/schematic.png)

## Starting point

The minimal unit of data required to run `SPOTlight` are:   \
- ST (sparse) matrix with the expression, raw or normalized, where rows = genes
and columns = capture locations.    \
- Single Cell (sparse) matrix with the expression, raw or normalized, where 
rows = genes and columns = cells.    \
- Vector indicating the cell identity for each column in the Single Cell 
expression matrix.    \

Data inputs can also be objects of class `r (SCE)("SpatialExperiment")` (SE), 
`r Biocpkg("SingleCellExperiment")` (SCE) or `r CRANpkg("Seurat")` objects from
which the minimal data will be extracted.

# Getting started

## Data description

For this vignette, we will use a SE put out by *10X Genomics* containing a 
Visium kidney slide. The raw data can be accessed [here](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Mouse_Kidney).

SCE data comes from the [*The Tabula Muris Consortium*](https://www.nature.com/articles/s41586-020-2496-1)
which contains >350,000 cells from from male and female mice belonging to six
age groups, ranging from 1 to 30 months. From this dataset we will only load the
kidney subset to map it to the Visium slide.


## Loading the data

Both datasets are available through Biocondcutor's `ExperimentHub` and can be loaded into R as follows: 

```{r eh, message = FALSE}
library(ExperimentHub)

# initialize a Hub instance which stores a complete set of recordd
eh <- ExperimentHub()

# retrieve any records that match our keyword(s) of interest
query(eh, "Tabula Muris Senis droplet Kidney")
```

Load the spatial data
```{r}
q <- query(eh, "MouseKidneyCoronal")  # retrieve 10X Kidney records
id <- q$ah_id[2]                      # specify dataset ID to load
spe <- eh[[id]]                       # load specified dataset
rownames(spe) <- rowData(spe)$symbol  # Change ensemblid to symbol
```

Load the single cell data
```{r}
q <- query(eh, "Tabula Muris Senis droplet Kidney")   # retrieve 10X Kidney records
q
```

Since we see that the data comes from the Tabula Muris Sensis dataset we can directly load the SCE object as follows:
```{r}
library(TabulaMurisSenisData)
sce <- TabulaMurisSenisDroplet(tissues = "Kidney")$Kidney
```

Quick data exploration
```{r}
table(colData(sce)$age, colData(sce)$free_annotation)
```

We see how there is a good representation of all the cell types across ages
except at 24m. In order to reduce the potential noise introduced by age and 
batch effects we are going to select cells all coming from the same age.

```{r}
 # Keep cells from 18m mice
sce <- subset(sce, , age == "18m")
# Keep cells with clear cell type annotations
sce <- subset(sce, , ! free_annotation %in% c("nan", "CD45")) 
```

# Workflow

## Preprocessing

If the dataset is very large we want to downsample it to train the model, 
both in of number of cells and number of genes. To do this, we want to keep
a representative amount of cells per cluster and the most important genes. 

In the paper we show how downsampling the number of cells per cell type to ~100
doesn't affect the performance of the model. Including more cells per cell identity provides marginal improvement while greatly increasing computational time and resources. Furthermore, restricting the gene set to the marker
genes for each cell type along with up to 3.000 highly variable genes further
optimizes performance and computational resources. You can find a more detailed
explanation in the original [paper](https://academic.oup.com/nar/article/49/9/e50/6129341).

### Feature selection
Our first step is to get the marker genes for each cell type. We follow the Normalization procedure as described in [OSCA](http://bioconductor.org/books/3.14/OSCA.basic/normalization.html). We first carry out library size normalization to correct for cell-specific biases:
```{r}
lib_sce <- librarySizeFactors(sce)
sizeFactors(sce) <- lib_sce
```

Once we have the size factor for each cell we scale and log transform the data to get get normalized expression values for each cell.
```{r}
sce <- logNormCounts(sce)
```

You can use whichever method you want as long as it returns a weight indicating the importance of that gene for that cell type. Examples can be `avgLogFC`, `AUC`, `pct.expressed`..., 
```{r}
colLabels(sce) <- colData(sce)$free_annotation

# Get vector  indicating which genes are neither ribosomal or mitochondrial
genes <- ! base::grepl(
  x = rownames(sce),
  pattern = "^Rp[l|s]|Mt")

# Compute marker genes
mgs <- scoreMarkers(sce, colLabels(sce), subset.row = genes)
```

Then we want to keep only those genes that are relevant for each cell identity
```{r}
mgs_ls <- lapply(names(mgs), \(i){
  x <- mgs[[i]]
  # Filter and keep relevant marker genes, those with AUC > 0.8
  x <- x[x$mean.AUC > 0.8, ]
  # Sort the genes from highest to lowest weight
  x <- x[order(x$mean.AUC, decreasing = TRUE), ]
  # Add gene and cluster id to the dataframe
  x$gene <- rownames(x)
  x$cluster <- i
  data.frame(x)
})

mgs_df <- dplyr::bind_rows(mgs_ls)
```

### Cell Downsampling

Next you randomly select up to 100 cells/cell identity If a cell type
is comprised of <100 cells than all the cells will be used. If we have very
biologically different cell identities (B cells vs T cells vs Macrophages vs
Epithelial) we can use fewer cells since their transcriptional profiles will 
be very different. In cases when we have more transcriptionally similar cell
identities we need to increase our N to capture the biological heterogeneity
between them.

For the purpose of this vignette and to speed up the analysis we are going to 
use 20 cells per cell identity
```{r}
n_cell <- 20
sce_ls <- split(colData(sce), sce$free_annotation)
id_keep <- lapply(sce_ls, function(.) {
  sample(
    x = rownames(.),
    size = ifelse(n_cell > nrow(.), nrow(.), n_cell),
    replace = FALSE)
  })

sce <- sce[, unlist(id_keep)]
```

## Deconvolution

You are now set to run `SPOTlight` to deconvolute the spots! Briefly 
y
# Get SPOTlight explanation from paper

You can visualize the above explanation in the following workflow scheme:

![](../inst/extdata/workflow.png)

```{r}
mgs_vec <- mgs_df$mean.AUC
names(mgs_vec) <- mgs_df$group_name
res <- SPOTlight(
  x = sce,
  y = as.matrix(counts(spe)), 
  groups = as.character(sce$free_annotation),
  mgs = mgs_df,
  weight_id = "mean.AUC",
  group_id = "cluster",
  gene_id = "gene")
```

```{r}
head(mat <- res[[2]])
err <- mat[,  ncol(mat)]
mat <- mat[, -ncol(mat)]
```

# Visualization

## Topic profiles

```{r}
mod <- res[[1]]

plotTopicProfiles(
  x = mod,
  y = as.character(sce$free_annotation),
  facet = FALSE,
  min_prop = 0.01,
  ncol = 1)
```

```{r}
plotTopicProfiles(
  x = mod,
  y = as.character(sce$free_annotation),
  facet = TRUE,
  min_prop = 0.01,
  ncol = 4)
```

```{r}
library(DT)
datatable(basis(mod), fillContainer = TRUE)
```

## Co-localization

Now that we know which cell types are found within each spot we can make a graph 
representing spatial interactions where cell types will have stronger edges 
between them the more often we find them within the same spot. 

See [here](https://www.r-graph-gallery.com/network.html) for additional graphical parameters.

```{r}
plotInteractions(mat, "heatmap")
plotInteractions(mat, "network")
```

## Scatterpie

```{r}
plotSpatialScatterpie(
  x = spe,
  y = mat,
  cell_types = colnames(y),
  img = FALSE,
  scatterpie_alpha = 1,
  pie_scale = 0.4)
```

# Session information

```{r session-info}
sessionInfo()
```

# References
